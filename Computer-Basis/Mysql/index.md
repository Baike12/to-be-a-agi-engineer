# 1	索引选择
- 如果有主键，默认主键作为索引
- 没有主键，选择第一个不包含null的列作为主键
- 上面两个都没有，innodb生成一个隐式自增的id列作为索引键
# 2	索引结构
b+树
![[Pasted image 20240918002618.png]]
- 只有叶子节点才保存数据
# 3	二级索引
二级索引叶子节点放的不是数据，而是主键索引。
使用二级索引的时候，先找到主键索引，再通过主键索引去找到数据，这叫**回表**；
不过如果要查的就是主键索引，那么就不需要回表了，这就是**覆盖索引**

# 4	索引类型
## 4.1	按字段特性
### 4.1.1	主键索引
索引列不能有null值
### 4.1.2	唯一索引
索引列的值必须唯一，不过可以为null，也只能有一个null
### 4.1.3	普通索引
普普通通，啥也不限制
### 4.1.4	前缀索引
对**字符类型**字段前几个字符建立的索引；
减少索引占用内存
## 4.2	按索引个数
### 4.2.1	单列索引
### 4.2.2	联合索引
索引是按从左到右的顺序建的，只有在左边索引值相等的情况下右边的索引才能生效，所以要符合最左前缀匹配原则
#### 4.2.2.1	联合索引的范围匹配
联合索引遇到范围匹配就会停止，范围匹配的索引可以用到，但是更右边的索引就用不到了
对于 > ：
- 只能用到范围查询索引
 对于 >=：
 -  在等于处可以用到右边的索引
对于between and：
- 可以用到右边的索引
对于前缀模糊匹配比如 j%：
- 在等于j处可以用到右边的索引
# 5	建立索引的要点
## 5.1	索引区分度
区分度 = 索引字段的值种类数 / 总数据量
## 5.2	建立联合索引
假设有一个这样的sql：查询 a = 1的情况下对b order by：
可以对（a，b）建立联合索引，这样b就是排好序的
## 5.3	建索引的情况
索引的缺点：
- 索引本身占用内存
- 创建和维护索引需要时间
- 增删改索引需要时间维护
### 5.3.1	需要索引的情况：
- 字段唯一的
- 被用于where的
- 被order by和goup by的
### 5.3.2	不需要的
- 不被order by和group by的
- 重复多的字段
- 经常被修改的字段
- 表数据少，不如直接全表扫描
# 6	索引优化
## 6.1	前缀索引
减少索引占用内存
缺点：
- order by不能用
- 前缀索引不能用做覆盖索引
## 6.2	覆盖索引
要查询的字段在b+树的叶子节点上都有，避免回表
## 6.3	主键自增
插入的时候：
- 不会因为插入一条数据移动页中的数据
## 6.4	主键最好not bull
- 优化器选择索引的时候更麻烦
- 如果存在null，行数据至少要用一个字节保存null值列表

# 7	索引失效
## 7.1	左模糊或者左右模糊匹配
左模糊匹配不一定造成索引失效：
- 要查询的数据是id列和name列，都在二级索引idx_name中，所以使用覆盖索引
- 使用了全索引扫描
![[Pasted image 20240918144043.png]]
再添加一个字段验证一下：
- 添加一个字段后，因为新加的字段不是索引，所以这时左模糊匹配不会走索引
- 新建一个联合索引之后就会走了
![[Pasted image 20240918145053.png]]
## 7.2	对索引进行了计算
## 7.3	联合索引不符合最左前缀匹配
## 7.4	where中or前是索引，or后不是索引

# 8	explain
![[Pasted image 20240918102928.png]]
## 8.1	type
扫描类型：
- all：全表
- index：全索引
- range：范围索引
- ref：非唯一索引
- eq_ref：唯一索引
- const：唯一索引或者只有一个值的索引，一般是where =
## 8.2	possible key
可能的索引
## 8.3	key
## 8.4	key_len
## 8.5	ref
## 8.6	rows
## 8.7	filtered
## 8.8	extra
- using filesort：group by时索引无法用于排序，只能文件排序
- using temporary：用了临时表保存中间结果，常见于order by和group by
- using index：使用了覆盖索引
# 9	count效率
## 9.1	原理
在server层维护一个counter，只要指定的参数不为null，就将counter加一
如果只有聚簇索引，就遍历聚簇索引，否则遍历二级索引，因为二级索引更轻，叶子节点只有聚簇索引而不是数据
## 9.2	cout（1）
不需要读参数值，只需要计数
## 9.3	count（* ）
会将* 转换成0，所以和count（1）一样快
## 9.4	cout(字段)
会全表扫描，效率最低
## 9.5	优化count（* ）
使用explain，不会真正去计数，给出一个估计值，不一定准确，但是大概对


