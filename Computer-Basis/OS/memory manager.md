#### 交换内存
- 在磁盘上，将内存中暂时用不到的数据页交换到磁盘上让出内存给需要的程序
#### 缺页中断
- 程序访问不在物理内存中的页面时，cpu触发一个中断，操作系统处理中断，将页面加载到物理内存中
- 发生时机
	- 首次访问一个页面
	- 已经被换出的页面再次访问
	- malloc分配内存时
### 页表
- 包含页号和页内偏移
#### 多级页表
- 一级页表有1024项，里面装的是一级页号和二级页表地址，可以覆盖整个内存区域
- 二级页表按需创建，用不到的就不创建，节省了页表消耗的内存
- 64位系统有四级页表
#### TLB
- 用于缓存最常访问的页表项
### 段页式内存管理
- 先找到段号、再找页号、最后找数据
### linux内存空间
#### 32位
- 低3G是用户空间
- 高1G是内核空间
#### 64位
- 低128T是用户空间
- 高128T是内核空间

### 动态内存分配
#### brk
- 将堆顶指针上移动
- 适用于简单场景，128K以下内存
#### mmap
- 从内存映射区获取内存，将文件映射到内存中
- 可以用于共享内存
- 支持内存保护，可以标记为只读、不可执行等
#### 预分配
- malloc分配多于所需内存大小
#### 释放
- malloc的内存free后不会归还操作系统
- mmap的会
#### 只使用mmap
- 频繁的中断
- 缺页：mmap每次释放内存都会归还系统，于是每次分配的虚拟内存地址都是缺页状态，然后在第一次访问该虚拟地址的时候，就会触发缺页中断
#### 只使用brk
- 不归还给系统也是一个问题：内存碎片
#### free
- 每次malloc会包含大小信息（16字节）在返回的指针前面，释放的时候将指针向左偏移16字节就得到大小
### 内存回收
#### 内存不够分配
- 内核线程后台回收
- 直接回收，阻塞分配过程
- 直接回收不够就会oom
#### 内存回收
- 文件页
	- 干净的直接回收
	- 脏的先写入磁盘再回首
- 匿名页：栈、堆等
	- 使用swap
- 都是基于LRU
#### 减少回收带来的性能损失
- 调整回收倾向：倾向与文件页回收
- 尽早触发内核线程异步回收，调整最小页阈值
```shell
cat /proc/sys/vm/min_free_kbytes
```
#### numa架构下的内存回收
- numa架构几个cpu组成一个node，每个node有自己的内存、io等
- 以下命令可以设置node的内存分配机制，设置为0时可以在自身内存不足时到其他node获取内存，虽然比获取自身内存代价大，但是比回收代价小
```shell
cat /proc/sys/vm/zone_reclaim_mode 
```
#### 使得进程不因为oom被杀掉
- oom_badness函数计算每个进程的得分来决定是否杀掉一个进程，越大越容易被杀
```shell
得分=进程使用的页面数+oom_score_adj*总页面数/1000
```
- 所以调整进程的oom_score_adj就可以一定程度上避免被杀
```shell
cat /proc/[pid]/oom_score_adj
```
### LRU
#### 问题
- 预读失效导致缓存命中率低
- 缓存污染导致缓存命中率低
#### 预读失效导致缓存命中率低
- 预读的没有被访问到，反倒把热点数据挤掉了
- 解决方法
	- 设置两个链表：活跃列表和非活跃列表
	- 对被预读的页，先进非活跃列表，挤掉非活跃列表的尾部页
	- 如果预读数据接下来被使用，会变成活跃列表的头，将活跃列表尾挤到非活跃列表头
	- 如果预读数据一直没被访问，会被挤掉
#### 缓存污染导致缓存命中率低
- 提高进入活跃列表的门槛：第二次被访问才进入活跃列表
#### mysql
- 也是类似思想，不过是在一个列表上，分为了young和old两个部分（63:37）

### 内核空间（32位）
- 所有进程共享
#### 直接映射区
- 前896M，映射到连续的物理内存
- 前16M用于DMA（物理内存的前16M）
### cpu读写内存
- cpu先发出虚拟地址，经过mmu转换成物理地址，放到地址总线，经过io桥，再经过存储总线的地址总线，到达内存控制器
- cpu发出控制信号，告诉内存控制器要读，内存控制器找到数据地址，将数据放到数据总线
- cpu读取数据总线返回的数据