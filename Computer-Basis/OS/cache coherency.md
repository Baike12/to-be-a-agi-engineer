### cache与内存一致性
#### 写直达
- 写入cache的时候就写到内存
- 性能差，写的时候和没用缓存一样
#### 写回
- 写的数据在cache中直接写入，然后把这一行cache line标记为脏的
- 写的数据不在cache中，找到当前要写的数据对应的cache行tl，查看这行tld是否是脏的
	- 脏的就把这一行写回内存tld，并把要写的数据块td加载到cache中
	- 不脏直接把要写的数据块td从内存覆盖到tl
- **还是不能避免多核心缓存不一致问题**
### 要求
#### 写传播
- 一个核心对cache的修改要传播到其他核心
#### 事务串行化
- 所有核心收到修改消息的顺序是一致的
### 实现
#### 总线嗅探
- 只能将消息传递，不能保证事务串行化
#### MESI协议
- 独占
	- 只有自己的cache有这个变量，可以直接修改
- 共享
	- **不止自己有，自己要修改之前要通知其他核心把这个变量置为失效**
- 已失效
	- 已经失效了，不能读取
- 已修改
	- cache中的变量修改过了，但是没同步到内存
	- **如果其他核心读取这个数据，本核心会将数据同步到内存中让其他核心取到最新数据**
	- 在一个cache中已修改的数据，在其他cache中肯定是失效的了，因为之前修改的时候通知了，再修改直接修改就行了。如果有其他核心读取了这个数据，那么会变成共享
- 已修改或独占时修改不用通知其他核心