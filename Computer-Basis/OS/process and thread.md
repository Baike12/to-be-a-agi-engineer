#### 并发与并行
- 并发是在一个cpu核心上交替执行多个任务
- 并行是在多个cpu上同时执行多个任务
### 进程
#### 状态
- 就绪态：原因：阻塞的事件完成、时间片用完
- 阻塞态：会被换到磁盘中，这就是挂起状态，挂起有两种情况
	- 就绪挂起：只要换到内存就能运行
	- 阻塞挂起：需要等待某个事件
	- 使用ctrl+z或者sleep也会导致进程挂起
#### PCB
- 进程唯一标识
##### 内容
- 进程描述信息：
	- 进程标识符：标识进程
	- 用户标识符：标识进程属主
- 进程管理信息
	- 状态
	- 优先级
- 资源
	- 内存和虚拟内存
	- 打开的文件列表
	- io设备
- cpu相关信息
	- cpu中相关寄存器的值
#### 进程控制
##### 创建
- 允许一个进程创建另一个进程，子进程可以继承父进程的资源
- 创建一个PCB，分配资源，将PCB加入就绪队列
##### 终止
- 找到pcb
- 如果在执行，立即停止执行
- 将子进程交给1号进程
##### 阻塞
- 自己可以阻塞自己，但是只能由其他进程唤醒
- 流程
	- 保护现场
	- 把PCB放到阻塞队列
##### 唤醒
- 如果一个进程调用的阻塞语句，一定有一个对应的唤醒语句
### 上下文切换
- 将前一个任务程序计数器和寄存器放到它的PCB中，将下一个任务的程序计数器加载到程序计数器和寄存器中
#### 进程上下文切换
- 发生在内核空间
- 包括：
	- 寄存器：程序计数器、通用寄存器、标志寄存器
	- 堆栈指针
	- 状态信息：进程状态、是否允许中断、优先级、调度信息：时间片、就绪队列位置
	- 内存管理信息：页表、全局变量、静态变量
	- 进入内核空间更新PCB
- 100微秒到1毫秒
- 触发情况
	- 时间片到了
	- 进程所需资源不足，进程也会挂起
	- 硬件中断
	- 优先级更高的任务执行
	- 主动挂起
#### 线程上下文切换
- 线程适用：多同一资源进行多步骤操作
- 切换
	- 不同进程：和进程切换一样
	- 同进程：
		- 寄存器：程序计数器、通用寄存器、标志寄存器
		- 堆栈指针
		- 状态信息：线程状态、优先级、时间片、就绪队列位置
		- TLS：线程局部存储、线程保存一些不被其他线程读写的数据
	- 不用切换：内存管理信息、文件描述符、网络套接字
#### 线程种类
- 用户线程
	- 由用户线程库创建、维护和调度
	- 优点：不经过系统调用，速度快
	- 缺点：一个线程系统调用阻塞了，其他线程都不能执行；线程切换只能等线程主动交出使用权
- 内核线程
	- 都在内核空间创建、维护、调度
	- 优点：一个线程阻塞不会影响其他线程
	- 缺点：系统调用消耗大
- 轻量级进程
	- 内核支持的用户线程、和内核线程一一对应
		- 与进程相比它只有一个最小的执行上下文和调度所需的统计信息
- linux中多个用户线程关联到多个lwp进程，每个lwp再关联一个内核线程
	- 用户线程较多、lwp较少，这样内核线程切换就比较少，而用户线程切换由用户线程管理器进行，消耗较低
	- 阻塞时：阻塞线程被剥离，用户线程管理器将其他用户线程绑定到当前用户内核线程
### 调度
#### 调度时机
- 需要运行另一个任务时
#### 调度原则
- io时切换
- 提高吞吐量：单位时间cpu完成任务的数量
- 降低周转时间：运行时间 + 等待时间 + 阻塞时间
- 考虑就绪队列任务的等待时间
- 强交互式应用及时响应
#### 调度算法
##### 先来先服务
- 直到任务完成
##### 最短作业优先
- 需要时间最短的优先
##### 高响应比优先
- 计算公式：优先权=（等待时间 + 需要的时间） / 需要的时间
- 实际不知道需要的时间
##### 时间片轮转
- 每个任务一个时间片，一般20到50毫秒
##### 最高优先级调度
- 静态优先级：创建任务时就确定
- 动态优先级：根据等待时间提高优先级
##### 多级反馈队列
- 设置多级队列，每个队列有优先级和执行时间片，优先级高的时间片小
- 反馈：高优先级任务来了抢占cpu
- 任务创建时先被放进最高级队列末尾


### 进程间通讯
- 通过内核：因为内核共享
#### 管道
- 随进程消亡
- 大小有限制
##### 匿名管道
- 使用|符号
- 是一个内存中的缓存，不在文件系统中
- 只能在父子之间通信，并且是单向了，双向需要两个管道
- 使用系统调用
##### 命名管道
- 使用mkfifo创建
- 往命名管道写输入会阻塞，直到有进程读出来
#### 消息队列
- 在内核中，以链表形式存在
- 消息发送时，放到链表中，消息被一个进程读取后，从链表清除
- 缺点：通信不及时、消息大小有限制、需要在内核和用户空间拷贝
#### 共享内存
- 多个进程不同的虚拟空间映射到同一物理空间
#### 信号量
- 实现互斥时：信号量设置为1，进程访问资源之前必须先P，离开之前先V
- 实现同步时：信号量设置为0，进程访问之前先P阻塞，直到有进程V
- P：将信号量 - 1，之后如果 < 0就阻塞
- V：将信号量 + 1，如果 < ＝0，说明有进程阻塞在信号量上，就把唤醒一个阻塞中的进程
- 将信号量设置为1就是互斥信号量
- 设置为0就是同步信号量，保证执行顺序
#### 信号
- 通过以下命令查看
```shell
kill -l
```
- 唯一的异步通信机制
- 进程对信号可以
	- 默认操作
	- 捕获信号自己处理
	- 忽略信号，但是SIGKILL和SIGSTOP不能忽略
#### socket
```cpp
int socket(int domain, int type, int protocal)
```
- domain：协议族
- type：字节流或数据报
- udp不需要三次握手、只需要创建socket然后bind
- socket也可以用于同一主机上的进程间通信，只需要bind一个本地文件

### 多线程
#### 互斥
- 临界区：操作共享资源的代码片段
#### 同步
- 用于指定执行顺序
#### 锁
-  自旋锁：获取不到锁就一直循环等待
-  无等待锁：获取不到就加入等待队列
#### 信号量
##### 生产者消费者问题
- 描述：
	- 生产者生产资源放在缓冲区
	- 消费者从缓冲区获取数据
	- 同时只能有一个生产者或消费者可以访问缓冲区
- 需要
	- 互斥量：1
	- 已有资源个数：0
	- 空位资源个数（空位也是一种资源）：n表示缓冲区大小
- 生产流程
	- 将空位资源P
	- 互斥量P
	- 生产数据放到缓冲区
	- 互斥量V
	- 已有资源V
- 消费流程
	- 已有资源P
	- 互斥量P
	- 拿走数据
	- 互斥量V
	- 空位资源V
##### 哲学家问题
- 解决方案：
	- 奇数编号的哲学家先拿左边再拿右边，偶数的相反，可以让两人同时进餐
##### 读写者问题
- 场景描述
	- 读读允许
	- 读写互斥
	- 写写互斥
### 一个进程可以创建多少个线程
- 使用以下命令可以查看一个线程的堆栈有多大
```shell
ulimit -a
```
- 用总内存除以这个值得到理论最大值
- 不过还受系统支持最大线程数、pid号等限制
### 线程崩溃会不会导致进程崩溃
- 在c++中会，因为线程崩溃一般是非法访问内存，线程共享进程中的内存，所以会崩
- 流程
	- 线程访问非法内存，操作系统检测到，给进程发送SIGSEGV信号，如果进程没有信号处理函数来处理这个进程，就会采用默认操作，停止进程
	- 这也是coredump文件产生过程，系统会在coredump文件保存到磁盘后停止进程，coredump文件由内核产生
