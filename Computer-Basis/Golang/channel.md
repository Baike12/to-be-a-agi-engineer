## channel
### 设计原理
- 鼓励通过通信共享内存
- 先入先出的
### 数据结构
#### 构成channel本身的：
- channel的容量、当前大小、channel元素类型
- 指向底层数组本身的指针
- 发送下标和接受下标
- 锁
#### 和协程相关的
- 发送队列和接收队列
### 发送数据
- 如果有读阻塞的直接发送到被阻塞的读协程，然后将读协程放到它的处理器的runnext中等待下一次调度就执行
- 如果缓冲区有空直接放到缓冲区
- 如果缓冲区没空，构建当前协程的sudog结构挂在channel的发送队列上，然后当前goroutine阻塞，让出cpu
### 接受数据
- 如果没有缓冲区，直接从发送者队列头的goroutine中拷贝数据，并释放发送队列头的协程，发送者队列没有协程的话就阻塞
- 如果有缓冲区，缓冲区不满，说明发送者队列没有协程，直接获取；缓冲区满，将当前接受下标的元素拷贝到当前接受者，然后将发送队列头的元素拷贝到缓冲区；没有数据，则阻塞当前线程并放到接受者队列中
- 如果channel已经关闭并且没有元素
- 如果从发送者队列获取了数据，发送者队列头的协程都会被唤醒添加到runnext
### 关闭
- 将发送队列和接收队列元素加入到glist，然后为glist中的协程触发调度